package com.example.test_app

import android.content.pm.PackageManager
import android.media.MediaRecorder
import android.os.Bundle
import android.os.Environment
import android.widget.ImageButton
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.example.test_app.databinding.ActivityPdfViewerBinding
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Color
import com.github.barteksc.pdfviewer.PDFView
import android.graphics.pdf.PdfRenderer
import android.media.AudioFormat
import android.media.AudioRecord
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.ParcelFileDescriptor
import android.util.Log
import android.util.TypedValue
import android.view.GestureDetector
import android.view.MotionEvent
import android.view.View
import android.view.animation.Animation
import android.widget.LinearLayout
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.FileProvider
import com.example.test_app.view.DrawingView
import com.example.test_app.model.Stroke
import com.example.test_app.model.TextAnnotation
import com.example.test_app.utils.MyDocManager
import com.example.test_app.utils.PdfExporter
import android.view.animation.AnimationUtils
import android.view.inputmethod.InputMethodManager
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.SeekBar
import com.yalantis.ucrop.UCrop
import java.io.FileOutputStream
import java.io.OutputStream
import java.io.RandomAccessFile
import androidx.core.graphics.createBitmap
import okhttp3.ResponseBody
import org.json.JSONObject
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import androidx.core.graphics.toColorInt
import androidx.core.view.isVisible
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import androidx.core.content.edit

@Suppress("DEPRECATION")
class PdfViewerActivity : AppCompatActivity() {

    /* ---------------- UI ---------------- */
    private lateinit var binding     : ActivityPdfViewerBinding
    private lateinit var pdfView     : PDFView
    private lateinit var drawingView : DrawingView

    /* ---------------- Îç∞Ïù¥ÌÑ∞ ---------------- */
    private val pageStrokes = mutableMapOf<Int, MutableList<Stroke>>()
    private val textAnnos   = mutableListOf<TextAnnotation>()
    private var currentPage = 0
    private var totalPages  = 0
    private lateinit var myDocPath: String

    /* ---------------- Î™®Îìú ---------------- */
    private var isPenMode = true
    private var isEraserMode = false
    private var isTextMode = false
    private var isTouchMode  = false
    //private var touchPassthrough = false

    /* ---------------- OCR ---------------- */
    private val ocrOptions   = arrayOf("ÌÖçÏä§Ìä∏ ÏöîÏïΩ", "Î≤àÏó≠")
    private var currentCropMode = 0
    private val AUTHORITY    by lazy { "${packageName}.fileprovider" }
    private val CROP_EXTRACT = 1001
    private val CROP_TRANS   = 1002

    /* ---------------- ÎÖπÏùå ---------------- */
    private var isRecording = false
    private var audioRecord: AudioRecord? = null // üîπ ÎÖπÏùåÍ∏∞ Í∞ùÏ≤¥
    private var audioFilePath: String = "" // üîπ Ï†ÄÏû•Îê† ÌååÏùº Í≤ΩÎ°ú
    private var recordingThread: Thread? = null

    /* ---------------- Sync ---------------- */
    private val handler = Handler(Looper.getMainLooper())
    private val syncRunnable = object : Runnable {
        override fun run() {
            drawingView.setPdfViewInfo(pdfView.zoom, pdfView.currentXOffset, pdfView.currentYOffset)
            handler.postDelayed(this, 10)
        }
    }

    /* ---------------- side menu ----------------*/
    private lateinit var sideMenu: LinearLayout
    private lateinit var btnMenu: ImageButton
    private lateinit var btnRecord: ImageButton
    private lateinit var btnOcr: ImageButton
    private lateinit var exportButton: ImageButton

    /* ---------------- Ïï†ÎãàÎ©îÏù¥ÏÖò ----------------*/
    private lateinit var slideDown: Animation
    private lateinit var slideUp: Animation

    /* ---------------- Ìéú ÏòµÏÖò ------------*/
    private lateinit var penOptionLayout: LinearLayout
    private lateinit var penSizeCircle: View
    private lateinit var penSizeSeekBar: SeekBar
    private lateinit var btnPen: ImageButton
    private lateinit var colorBlack: View
    private lateinit var colorBlue: View
    private lateinit var colorGreen: View
    private lateinit var colorRed: View
    private lateinit var colorYellow: View

    /* ---------------- ÏßÄÏö∞Í∞ú ÏòµÏÖò ------------*/
    private lateinit var btnEraser: ImageButton
    private lateinit var eraserSizeCircle  : View

    /* ---------------- ÏßÄÏö∞Í∞ú ÏòµÏÖò ------------*/
    private lateinit var btnText: ImageButton

    /* ---------- ÌÖçÏä§Ìä∏Î•º ÏúÑÌïú Ï†úÏä§Ï≤ò ÏòµÏÖò ----------*/
    private lateinit var gestureDetector: GestureDetector

    private lateinit var btnHand: ImageButton

    private var isMenuOpen = false

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        //Î∞îÏù∏Îî© Í∞ùÏ≤¥ ÌöçÎìù
        binding = ActivityPdfViewerBinding.inflate(layoutInflater)

        setContentView(binding.root)

        // PDF Î∑∞Ïñ¥, ÌïÑÍ∏∞ Î∑∞ Ï¥àÍ∏∞Ìôî
        pdfView = binding.pdfView
        drawingView = binding.drawingView

        /* --- myDoc Î°úÎìú --- */
        myDocPath = intent.getStringExtra("myDocPath") ?: return
        val myDoc = MyDocManager(this).loadMyDoc(File(myDocPath))
        totalPages = getTotalPages(File(myDoc.pdfFilePath))


        // Ï†ÄÏû•Îêú strokeÎì§ÏùÑ ÌéòÏù¥ÏßÄÎ≥ÑÎ°ú Î∂ÑÎ¶¨ (strokeÏùò page Í∞íÏù¥ ÏûàÎã§Î©¥ ÏÇ¨Ïö©)
        myDoc.strokes.groupBy { it.page }.forEach { (p, s) -> pageStrokes[p] = s.toMutableList() }
        if (pageStrokes.isEmpty()) pageStrokes[0] = mutableListOf()
        textAnnos.addAll(myDoc.annotations)

        loadPage(0)                    // Ï≤´ ÌéòÏù¥ÏßÄ

        // "Îã§Ïùå ÌéòÏù¥ÏßÄ" Î≤ÑÌäº
        binding.nextPageButton.setOnClickListener {
            updateCurrentPageStrokes()
            dumpTextBoxes()
            saveAndClearTextBoxes()      // EditText Ï†ÄÏû•¬∑Ï†úÍ±∞
            if (currentPage < totalPages - 1) loadPage(currentPage + 1)
        }

        // "Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄ" Î≤ÑÌäº
        binding.prevPageButton.setOnClickListener {
            updateCurrentPageStrokes()
            dumpTextBoxes()
            saveAndClearTextBoxes()      // EditText Ï†ÄÏû•¬∑Ï†úÍ±∞
            if (currentPage > 0) loadPage(currentPage - 1)
        }

        // Î™®Îìú Ï†ÑÌôò Î≤ÑÌäº
        btnHand = findViewById(R.id.toggleModeButton)

        btnHand.setOnClickListener {
            isTouchMode = true
            isPenMode = false
            isEraserMode = false
            isTextMode = false

            drawingView.setDrawingEnabled(false)
            drawingView.setEraserEnabled(false)

            updateButtonAlpha(btnHand)
        }



        // Export Î≤ÑÌäºÏùÄ Í∏∞Ï°¥ Î°úÏßÅ Í∑∏ÎåÄÎ°ú
        exportButton = findViewById(R.id.exportButton)

        exportButton.setOnClickListener {
            exportToPdf()
        }

        //OCR Í∏∞Îä•
        btnOcr = findViewById(R.id.btnOcr)

        //OCR Î≤ÑÌäº Í∏∞Îä•
        btnOcr.setOnClickListener {
            showOcrDialog()
        }

        // Îí§Î°ú Í∞ÄÍ∏∞ Î≤ÑÌäº
        val btnBack = findViewById<ImageButton>(R.id.btnBack)

        // Îí§Î°ú Í∞ÄÍ∏∞ Î≤ÑÌäº Í∏∞Îä•
        btnBack.setOnClickListener {
            persistAll()
            onBackPressedDispatcher.onBackPressed()
            Toast.makeText(this, "Ï†ÄÏû• ÏôÑÎ£å",Toast.LENGTH_SHORT).show()
        }

        // ÎÖπÏùå Î≤ÑÌäº
        btnRecord = findViewById(R.id.btnRecord)

        btnRecord.setOnClickListener {
            println("ÎÖπÏùå Î≤ÑÌäºÏù¥ ÌÅ¥Î¶≠Îê®!")
            if (isRecording) {
                stopRecording(btnRecord)
            } else {
                startRecording(btnRecord)
            }
        }

        // ÏÇ¨Ïù¥Îìú Î©îÎâ¥
        sideMenu = findViewById(R.id.sideMenu)

        slideUp = AnimationUtils.loadAnimation(this, R.anim.slide_up)
        slideDown = AnimationUtils.loadAnimation(this, R.anim.slide_down)

        // ÌñÑÎ≤ÑÍ±∞
        btnMenu = findViewById(R.id.btnMenu)

        btnMenu.setOnClickListener { toggleSideMenu() }

        // Ìéú, ÏßÄÏö∞Í∞ú
        btnPen = findViewById(R.id.btnPen)
        btnEraser = findViewById(R.id.btnEraser)
        penOptionLayout = findViewById(R.id.penOptionLayout)
        penSizeCircle = findViewById(R.id.penSizeCircle)
        penSizeSeekBar = findViewById(R.id.penSizeSeekBar)

        colorBlack  = findViewById(R.id.colorBlack)
        colorBlue   = findViewById(R.id.colorBlue)
        colorGreen  = findViewById(R.id.colorGreen)
        colorRed    = findViewById(R.id.colorRed)
        colorYellow = findViewById(R.id.colorYellow)

        updateToolSize(penSizeSeekBar.progress)

        btnPen.setOnClickListener {
            exitTouchMode()
            if (!isPenMode) {
                isPenMode    = true
                isEraserMode = false
                isTextMode   = false
                drawingView.setDrawingEnabled(true)
                drawingView.setEraserEnabled(false)
                penOptionLayout.visibility = View.GONE
                setTextBoxesEnabled(false)    // EditText ÎπÑÌôúÏÑ±
            } else {
                penOptionLayout.visibility =
                    if (penOptionLayout.isVisible) View.GONE else View.VISIBLE
            }
            updateButtonAlpha(btnPen)
        }



        penSizeSeekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(sb: SeekBar, prog: Int, fromUser: Boolean) {
                if (!isEraserMode) updateToolSize(prog)
            }
            override fun onStartTrackingTouch(sb: SeekBar) {}
            override fun onStopTrackingTouch(sb: SeekBar)  {}
        })

        colorBlack.setOnClickListener { applyPenColor(Color.BLACK) }
        colorBlue.setOnClickListener { applyPenColor("#025AB1".toColorInt()) }
        colorGreen.setOnClickListener { applyPenColor("#2E7D32".toColorInt()) }
        colorRed.setOnClickListener { applyPenColor("#C62828".toColorInt()) }
        colorYellow.setOnClickListener { applyPenColor("#F9A825".toColorInt()) }

        btnEraser.setOnClickListener {
            exitTouchMode()
            if (!isEraserMode) {
                isPenMode    = false
                isEraserMode = true
                isTextMode   = false
                drawingView.setEraserEnabled(true)
                drawingView.setDrawingEnabled(false)
                penOptionLayout.visibility = View.GONE
                updateButtonAlpha(btnEraser)
                setTextBoxesEnabled(false)
            }
        }


        // ÌÖçÏä§Ìä∏ Í¥ÄÎ†® ÏÑ§Ï†ï
        btnText = findViewById(R.id.btnText)
        btnText.setOnClickListener {
            exitTouchMode()
            isTextMode   = true
            isTouchMode = false
            isPenMode = false
            isEraserMode = false

            drawingView.setDrawingEnabled(false)
            drawingView.setEraserEnabled(false)
            penOptionLayout.visibility = View.GONE
            updateButtonAlpha(btnText)

            setTextBoxesEnabled(isTextMode)     // ‚Üê ÌÖçÏä§Ìä∏ Î™®Îìú ON/OFF Ïãú EditText ÌôúÏÑ±/ÎπÑÌôúÏÑ±
        }

        // ÌÖçÏä§Ìä∏ Î™®ÎìúÏóêÏÑú ÎçîÎ∏îÌÉ≠
        gestureDetector = GestureDetector(this,
            object: GestureDetector.SimpleOnGestureListener() {
                override fun onDoubleTap(e: MotionEvent): Boolean {
                    if (isTextMode) {
                        addTextBoxAt(e.x, e.y)   // ÌÖçÏä§Ìä∏ Î∞ïÏä§Îßå Ï∂îÍ∞Ä
                        return true              // Î™®ÎìúÎäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
                    }
                    return false
                }
            })
        // pdfÎ∑∞Ïóê ÌÑ∞Ïπò Î¶¨Ïä§ÎÑà Î∂ôÏù¥Í∏∞
        pdfView.setOnTouchListener { _, ev ->
            // ‚ë† ÌÖçÏä§Ìä∏ Î™®ÎìúÏùº Îïå, ÏïÑÎ¨¥ Í≥≥Ïù¥ÎÇò ÎàÑÎ•¥Î©¥ Ïª§ÏÑú¬∑ÌÇ§Î≥¥Îìú Ïà®ÍπÄ
            if (isTextMode && ev.action == MotionEvent.ACTION_DOWN) {
                currentFocus?.let { v ->
                    if (v is EditText) {
                        v.clearFocus()
                        val imm = getSystemService(Context.INPUT_METHOD_SERVICE)
                                as InputMethodManager
                        imm.hideSoftInputFromWindow(v.windowToken, 0)
                    }
                }
            }

            // ‚ë° ÌÖçÏä§Ìä∏ Î™®Îìú ÏûêÏ≤¥Ïùò ÎçîÎ∏îÌÉ≠ Ï≤òÎ¶¨
            if (isTextMode) {
                gestureDetector.onTouchEvent(ev)
                return@setOnTouchListener true   // Ïù¥Î≤§Ìä∏ ÏÜåÎπÑ
            }
            false                                 // Îã§Î•∏ Î™®Îìú ‚Üí PDFView Í∏∞Î≥∏ Ï†úÏä§Ï≤ò ÌóàÏö©
        }

        handler.post(syncRunnable)
    }

    override fun onDestroy() {
        super.onDestroy(); handler.removeCallbacks(syncRunnable)
    }

    /* =============================================================== */
    /*  ÌéòÏù¥ÏßÄ Î°úÎìú                                                    */
    /* =============================================================== */
    private fun loadPage(index: Int) {
        currentPage = index
        pdfView.fromFile(File(getBasePdfPath()))
            .enableSwipe(true)
            .enableDoubletap(true)
            .pages(index)
            .onLoad {
                drawingView.setCurrentPage(currentPage)
                drawingView.setStrokes(pageStrokes[currentPage] ?: mutableListOf())
                drawingView.setTextAnnotations(textAnnos)
            }.load()
    }

    /* =============================================================== */
    /*  OCR ‚Üí uCrop                                                   */
    /* =============================================================== */
    private fun showOcrDialog() {
        AlertDialog.Builder(this)
            .setItems(ocrOptions) { _, w -> currentCropMode = if (w == 0) CROP_EXTRACT else CROP_TRANS
                startCrop(currentCropMode) }
            .show()
    }

    // OCR Í≤∞Í≥ºÎ•º ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ°ÌïòÏó¨ ÏöîÏïΩ ÏöîÏ≤≠ (Termux Flask ÏÑúÎ≤ÑÎ°ú POST)
    private fun sendTextForSummarization(extractedText: String) {

        val sharedPreferences = getSharedPreferences("auth_prefs", Context.MODE_PRIVATE)

        val accessToken = sharedPreferences.getString("access_token", null)

        if (accessToken == null) {
            Toast.makeText(this, "Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.", Toast.LENGTH_SHORT).show()
            return
        }

        val request = SummarizeRequest(extractedText)

        val call = RetrofitClient.fileUploadService.summarizeText("Bearer $accessToken", request)

        call.enqueue(object : Callback<ResponseBody> {
            override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                if (response.isSuccessful) {
                    val responseBody = response.body()?.string()

                    try {

                        val json = JSONObject(responseBody ?: "")

                        val taskId = json.optString("task_id", "")

                        // task_idÎ•º SummarizeActivityÏôÄ Í∞ôÏùÄ SharedPreferencesÏóê Ï†ÄÏû•
                        saveSummaryTaskId(taskId)

                        Log.d("OCR_SUMMARIZE", "ÏÑúÎ≤Ñ ÏöîÏïΩ ÏöîÏ≤≠ ÏôÑÎ£å (Task ID: $taskId)")

                        Toast.makeText(this@PdfViewerActivity, "ÏöîÏïΩ ÏöîÏ≤≠Ïù¥ Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.", Toast.LENGTH_SHORT).show()
                    } catch (e: Exception) {
                        Toast.makeText(this@PdfViewerActivity, "ÏùëÎãµ ÌååÏã± Ïò§Î•ò", Toast.LENGTH_SHORT).show()
                        Log.e("OCR_SUMMARIZE", "ÏùëÎãµ ÌååÏã± Ïò§Î•ò: ${e.message}")
                    }
                }

                else {
                    val errorBody = response.errorBody()?.string()
                    Log.e("OCR_SUMMARIZE", "ÏöîÏïΩ ÏöîÏ≤≠ Ïã§Ìå®: ${response.code()} - $errorBody")
                    Toast.makeText(this@PdfViewerActivity, "ÏöîÏïΩ ÏöîÏ≤≠ Ïã§Ìå®: ${response.code()}", Toast.LENGTH_SHORT).show()
                }
            }

            override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                Toast.makeText(this@PdfViewerActivity, "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: ${t.message}", Toast.LENGTH_SHORT).show()
            }
        })
    }

    // ÌÅ¨Î°≠ ÏûëÏóÖ ÏãúÏûë (UCrop ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÇ¨Ïö©)
    private fun startCrop(reqCode: Int) {
        val scale = 1080f / pdfView.width
        val bmp = createBitmap(
            (pdfView.width * scale).toInt(),
            (pdfView.height * scale).toInt(),
            Bitmap.Config.RGB_565
        )
        Canvas(bmp).apply { scale(scale, scale); pdfView.draw(this); drawingView.draw(this) }

        val srcFile = File(cacheDir, "crop_src_${System.currentTimeMillis()}.jpg")
        FileOutputStream(srcFile).use { bmp.compress(Bitmap.CompressFormat.JPEG, 85, it) }
        bmp.recycle(); System.gc()

        val srcUri = FileProvider.getUriForFile(this, AUTHORITY, srcFile)
        val dstUri = Uri.fromFile(File(cacheDir, "crop_dst_${System.currentTimeMillis()}.jpg"))

        UCrop.of(srcUri, dstUri)
            .withOptions(UCrop.Options().apply {
                setCompressionFormat(Bitmap.CompressFormat.JPEG); setFreeStyleCropEnabled(true)
            })
            .withAspectRatio(0f, 0f)
            .start(this, reqCode)
    }

    @Deprecated("This method has been deprecated in favor of using the Activity Result API\n      which brings increased type safety via an {@link ActivityResultContract} and the prebuilt\n      contracts for common intents available in\n      {@link androidx.activity.result.contract.ActivityResultContracts}, provides hooks for\n      testing, and allow receiving results in separate, testable classes independent from your\n      activity. Use\n      {@link #registerForActivityResult(ActivityResultContract, ActivityResultCallback)}\n      with the appropriate {@link ActivityResultContract} and handling the result in the\n      {@link ActivityResultCallback#onActivityResult(Object) callback}.")
    // Ïù¥ÎØ∏ÏßÄ ÌÅ¨Î°≠ Í≤∞Í≥º Ï≤òÎ¶¨ (OCR ÏàòÌñâ)
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode != RESULT_OK || data == null) return
        val cropped = contentResolver.openInputStream(UCrop.getOutput(data) ?: return)
            ?.use { BitmapFactory.decodeStream(it) } ?: return
        when (requestCode) {
            CROP_EXTRACT -> runOcr(cropped)
            CROP_TRANS   -> runTranslate(cropped)
        }
    }

    /* =============================================================== */
    /*  OCR ÏàòÌñâ                                                       */
    /* =============================================================== */
    private fun runOcr(bmp: Bitmap) {
        ReadImageText().processImage(bmp) { extracted ->
            runOnUiThread {
                if (currentCropMode == CROP_EXTRACT) {
                    sendTextForSummarization(extracted)
                } else {
                    addTextAnno(extracted)
                }
            }
        }
    }

    private fun saveSummaryTaskId(taskId: String) {
        val sharedPreferences = getSharedPreferences("auth_prefs", Context.MODE_PRIVATE)
        val existingJson = sharedPreferences.getString("summary_task_id_list", "[]")
        val type = object : TypeToken<MutableList<String>>() {}.type
        val taskIdList: MutableList<String> = Gson().fromJson(existingJson, type)

        taskIdList.add(taskId)

        val newJson = Gson().toJson(taskIdList)
        sharedPreferences.edit { putString("summary_task_id_list", newJson) }
    }


    /* ---------- Î¨∏ÏûêÏó¥ ÎûòÌïë ---------- */
    private fun wrapText(src: String, maxChars: Int = 10): String {
        val words = src.split("\\s+".toRegex())
        val sb = StringBuilder()
        var lineLen = 0
        for (w in words) {
            if (lineLen + w.length + 1 > maxChars) {
                sb.append('\n'); lineLen = 0
            } else if (lineLen > 0) {
                sb.append(' '); lineLen++
            }
            sb.append(w); lineLen += w.length
        }
        return sb.toString()
    }

    private fun addTextAnno(raw: String) {
        val wrapped = wrapText(raw)      // ‚Üê 40Í∏ÄÏûêÎßàÎã§ Ï§ÑÎ∞îÍøà
        val cx = pdfView.width / 2f
        val cy = pdfView.height / 2f
        val pdfX = (cx - pdfView.currentXOffset) / pdfView.zoom
        val pdfY = (cy - pdfView.currentYOffset) / pdfView.zoom

        textAnnos += TextAnnotation(currentPage, wrapped, pdfX, pdfY, 40f)
        drawingView.setTextAnnotations(textAnnos)
    }
    /* ---------- ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏùò EditTextÎ•º Ï†ÄÏû•ÌïòÍ≥† Ï†úÍ±∞ ---------- */
    private fun saveAndClearTextBoxes() {
        //collectTextBoxesToAnnotations()      // ‚ù∂ EditText ‚Üí TextAnnotation  (ÏïûÏÑú ÎßåÎì† Ìï®Ïàò)
        val toRemove = mutableListOf<View>()
        for (i in 0 until binding.root.childCount) {
            val v = binding.root.getChildAt(i)
            if (v is EditText) toRemove += v
        }
        toRemove.forEach { binding.root.removeView(it) }
    }

    private fun runTranslate(bmp: Bitmap) {
        ReadImageText().processImage(bmp) { extractedText ->
            val intent = Intent(this, TranslateActivity::class.java)
            intent.putExtra("ocrText", extractedText)
            startActivity(intent)
        }
    }

    /* =============================================================== */
    /*  Ï†ÄÏû• / Î°úÎìú                                                    */
    /* =============================================================== */
    private fun updateCurrentPageStrokes() {
        val strokes = drawingView.getStrokes().toMutableList()
        strokes.forEach { it.page = currentPage }
        pageStrokes[currentPage] = strokes
    }
    /* ---------- ‚ù∂ EditText ‚Üí TextAnnotation Î≥ÄÌôò ---------- */
//    private fun collectTextBoxesToAnnotations() {
//
//        val newAnnos = mutableListOf<TextAnnotation>()
//
//        // Î∑∞ Ìä∏Î¶¨ÏóêÏÑú EditTextÎ•º Î™®Îëê Ï∞æÏïÑ PDF Ï¢åÌëúÎ°ú ÌôòÏÇ∞
//        for (i in 0 until binding.root.childCount) {
//            val v = binding.root.getChildAt(i)
//            if (v !is EditText) continue
//            if (v.text.isNullOrBlank()) continue   // ÎÇ¥Ïö©Ïù¥ ÏóÜÏúºÎ©¥ Í±¥ÎÑàÎúÄ
//
//            // ÌôîÎ©¥(View) Ï¢åÌëú ‚Üí PDF Ï¢åÌëú
//            val lp = v.layoutParams as FrameLayout.LayoutParams
//            val viewX = lp.leftMargin.toFloat()
//            val viewY = lp.topMargin.toFloat()
//            val pdfX  = (viewX - pdfView.currentXOffset) / pdfView.zoom
//            val pdfY  = (viewY - pdfView.currentYOffset) / pdfView.zoom
//
//            newAnnos += TextAnnotation(
//                page     = currentPage,
//                text     = v.text.toString(),
//                x        = pdfX,
//                y        = pdfY,
//                fontSize = 40f               // ÌïÑÏöîÌïòÎ©¥ v.textSize Î°ú ÎåÄÏ≤¥
//            )
//        }
//
//        // Í∞ôÏùÄ ÌéòÏù¥ÏßÄÏùò ÏòàÏ†Ñ Ï£ºÏÑùÏùÑ ÏßÄÏö∞Í≥† ÏÉàÎ°ú Î∞òÏòÅ
//        textAnnos.removeAll { it.page == currentPage }
//        textAnnos.addAll(newAnnos)
//    }

    private fun persistAll() {
        updateCurrentPageStrokes()
        dumpTextBoxes()
        MyDocManager(this).saveMyDoc(
            File(myDocPath).name,
            getBasePdfPath(),
            pageStrokes.values.flatten(),
            textAnnos
        )
    }

    private fun getBasePdfPath(): String =
        MyDocManager(this).loadMyDoc(File(myDocPath)).pdfFilePath

    private fun getTotalPages(file: File): Int =
        PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY))
            .use { it.pageCount }

    /* =============================================================== */
    /*  Export                                                         */
    /* =============================================================== */
    private fun exportToPdf() {
        persistAll()
        PdfExporter.export(this, myDocPath, "Exported_${System.currentTimeMillis()}.pdf")
    }

    /* =============================================================== */
    /*  Îí§Î°úÍ∞ÄÍ∏∞                                                       */
    /* =============================================================== */
    @Deprecated("Deprecated due to AndroidX API changes")
    override fun onBackPressed() { persistAll(); super.onBackPressed() }

    /* =============================================================== */
    /*  Ìéú, ÏßÄÏö∞Í∞ú Í¥ÄÎ†®                                                  */
    /* =============================================================== */
    private fun updateButtonAlpha(active: ImageButton?) {
        val all = listOf(btnPen, btnEraser, btnText, btnHand)
        all.forEach { it.alpha = if (it == active) 1.0f else 0.4f }
    }
    private fun updateToolSize(sizeDp: Int){
        val dp = sizeDp.coerceAtLeast(1)
        val px = dpToPx(dp)
        if(isEraserMode){
            resizeCircle(eraserSizeCircle, px)
        }else{
            drawingView.setCurrentStrokeWidth(dp.toFloat())
            resizeCircle(penSizeCircle, px)
        }
    }
    /** dp ‚Üí px Î≥ÄÌôò */
    private fun dpToPx(dp: Int): Int {
        return TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP,
            dp.toFloat(),
            resources.displayMetrics
        ).toInt()
    }
    private fun applyPenColor(color: Int){
        drawingView.setCurrentStrokeColor(color)
        penSizeCircle.background.setTint(color)
        btnPen.setColorFilter(color)
    }
    /** Î∑∞ ÌÅ¨Í∏∞(px Îã®ÏúÑ) Î≥ÄÍ≤Ω */
    private fun resizeCircle(view: View, sizePx: Int) {
        view.layoutParams = view.layoutParams.apply {
            width = sizePx
            height = sizePx
        }
        view.requestLayout()
    }
    /* =============================================================== */
    /*  ÌÖçÏä§Ìä∏ Î∞ïÏä§                                                      */
    /* =============================================================== */
    @SuppressLint("ClickableViewAccessibility")
    private fun addTextBoxAt(viewX: Float, viewY: Float){
        // ÏÉàÎ°úÏö¥ EditText
        val et = EditText(this).apply{
            setBackgroundResource(R.drawable.text_box_drawable)
            setTextColor(Color.BLACK)
            isSingleLine = false
            setTextSize(TypedValue.COMPLEX_UNIT_SP, 24f)
            //ÎÇ¥Î∂Ä Ìå®Îî©
            setPadding(8, 8, 8, 8)

            // Ìè¨Ïª§Ïä§ ÏûÉÏóàÏùÑ Îïå ÎÇ¥Ïö© ÏóÜÏúºÎ©¥ ÏûêÎèô ÏÇ≠Ï†ú
            onFocusChangeListener = View.OnFocusChangeListener { v, hasFocus ->
                if (!hasFocus && text.isNullOrBlank()) {
                    (v.parent as? FrameLayout)?.removeView(v)
                }
            }
        }

        // ÏúÑÏπòÎäî ÌÑ∞Ïπò ÏßÄÏ†êÏóê Ï§ëÏïô Ï†ïÎ†¨
        val params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT,
            FrameLayout.LayoutParams.WRAP_CONTENT
        )
        params.leftMargin = (viewX - 20.dp).toInt()
        params.topMargin  = (viewY - 10.dp).toInt()
        binding.root.addView(et, params)

        et.setOnTouchListener(MoveTouchListener())
        // Ìè¨Ïª§Ïä§ Î∞õÍ≥† ÌÇ§Î≥¥Îìú ÎùÑÏö∞Í∏∞
        et.requestFocus()
        et.post{
            val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            imm.showSoftInput(et, InputMethodManager.SHOW_IMPLICIT)
        }
    }
    // ÌÖçÏä§Ìä∏ Î∞ïÏä§ Ïù¥Îèô Ï†ÑÏö© ÌÅ¥ÎûòÏä§
    inner class MoveTouchListener : View.OnTouchListener {
        private var lastX = 0f
        private var lastY = 0f

        @SuppressLint("ClickableViewAccessibility")
        override fun onTouch(v: View, ev: MotionEvent): Boolean {
            // Ïª§ÏÑú(Ìè¨Ïª§Ïä§) ÏûàÏùÑ ÎïåÎßå Ïù¥Îèô ‚Äî Ìè¨Ïª§Ïä§ ÏóÜÏúºÎ©¥ ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù¬∑Ïä§ÌÅ¨Î°§ Îì±Ïóê Î∞©Ìï¥ÌïòÏßÄ ÏïäÏùå
            if (!(v as EditText).isFocused) return false

            when (ev.actionMasked) {
                MotionEvent.ACTION_DOWN -> {
                    lastX = ev.rawX
                    lastY = ev.rawY
                    return true           // ÎÇ¥Í∞Ä DOWN ÏùÑ ÏÜåÎπÑÌï®
                }
                MotionEvent.ACTION_MOVE -> {
                    val dx = (ev.rawX - lastX).toInt()
                    val dy = (ev.rawY - lastY).toInt()
                    val lp = v.layoutParams as FrameLayout.LayoutParams
                    lp.leftMargin += dx
                    lp.topMargin  += dy
                    v.layoutParams = lp
                    lastX = ev.rawX
                    lastY = ev.rawY
                    return true
                }
            }
            return false
        }
    }
    // dp ÌôïÏû•ÌîÑÎ°úÌçºÌã∞
    private val Int.dp: Float
        get() = this * resources.displayMetrics.density
    // ÌÖçÏä§Ìä∏ Î∞ïÏä§Îì§Ïùò Î™®Îìú Ï†ÑÌôò
    private fun setTextBoxesEnabled(enable: Boolean) {
        for (i in 0 until binding.root.childCount) {
            val v = binding.root.getChildAt(i)
            if (v is EditText) {
                v.isFocusableInTouchMode = enable
                v.isFocusable = enable
                v.isClickable = enable
                // Ïù¥ÎèôÏö© ÌÑ∞Ïπò Î¶¨Ïä§ÎÑàÎèÑ ÏºúÍ±∞ÎÇò ÎÅî
                if (enable) {
                    v.setOnTouchListener(MoveTouchListener())
                } else {
                    v.setOnTouchListener(null)
                    v.clearFocus()
                }
            }
        }
        // ÌÖçÏä§Ìä∏ Î™®Îìú Ï¢ÖÎ£å Ïãú ÌÇ§Î≥¥Îìú ÎÇ¥Î¶¨Í∏∞
        if (!enable) {
            drawingView.isClickable = true
            currentFocus?.let { view ->
                val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                imm.hideSoftInputFromWindow(view.windowToken, 0)
            }
        }
    }
    /* ---------- EditText ‚Üí TextAnnotation ---------- */
    private fun dumpTextBoxes(): Boolean {

        val newAnnos = mutableListOf<TextAnnotation>()
        val toRemove = mutableListOf<View>()

        // ‚îÄ‚îÄ 1. Î™®Îì† EditText Ïä§Ï∫î ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        for (i in 0 until binding.root.childCount) {
            val v = binding.root.getChildAt(i)
            if (v !is EditText) continue      // ÌÖçÏä§Ìä∏ Î∞ïÏä§ ÏïÑÎãê Îïå
            if (v.text.isNullOrBlank()) {     // ÎÇ¥Ïö© ÏóÜÏúºÎ©¥ Í∑∏ÎÉ• ÏßÄÏõÄ
                toRemove += v; continue
            }

            /* ÌôîÎ©¥(View) Ï¢åÌëú ‚Üí PDF Ï¢åÌëú Î≥ÄÌôò */
            val lp    = v.layoutParams as FrameLayout.LayoutParams
            val viewX = lp.leftMargin.toFloat()
            val viewY = lp.topMargin.toFloat()
            val pdfX  = (viewX - pdfView.currentXOffset) / pdfView.zoom
            val pdfY  = (viewY - pdfView.currentYOffset) / pdfView.zoom

            /* Í∏ÄÍº¥ ÌÅ¨Í∏∞Î•º PDF Ïä§ÏºÄÏùº Í∏∞Ï§ÄÏúºÎ°ú ÌôòÏÇ∞ */
            val fontPdf = v.textSize / pdfView.zoom       // ‚Üê Ï§å Î∞∞Ïú® Î≥¥Ï†ïÏù¥ ÌïµÏã¨

            newAnnos += TextAnnotation(
                page     = currentPage,
                text     = v.text.toString(),
                x        = pdfX,
                y        = pdfY,
                fontSize = fontPdf
            )

            toRemove += v          // Î≥ÄÌôòÏù¥ ÎÅùÎÇ¨ÏúºÎØÄÎ°ú Î∑∞Îäî Ï†úÍ±∞ ÎåÄÏÉÅÏúºÎ°ú ÌëúÏãú
        }

        // ‚îÄ‚îÄ 2. EditText Ïã§Ï†ú Ï†úÍ±∞ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        toRemove.forEach { binding.root.removeView(it) }

        if (newAnnos.isEmpty()) return false   // Ï†ÄÏû•Ìï† Í≤ÉÏù¥ ÏóÜÏúºÎ©¥ Î∞îÎ°ú Ï¢ÖÎ£å

        // ‚îÄ‚îÄ 3. Í∏∞Ï°¥ Ïñ¥ÎÖ∏ÌÖåÏù¥ÏÖòÍ≥º Î≥ëÌï©(Ï§ëÎ≥µ ÏúÑÏπòÎäî ÎçÆÏñ¥Ïì∞Í∏∞) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        for (na in newAnnos) {
            textAnnos.removeAll { it.page == na.page &&
                    kotlin.math.abs(it.x - na.x) < 2f &&
                    kotlin.math.abs(it.y - na.y) < 2f }
            textAnnos += na      // ÎàÑÏ†Å(add) ‚Äì ÌéòÏù¥ÏßÄ Ï†ÑÏ≤¥Î•º ÏßÄÏö∞ÏßÄ ÏïäÏùå
        }

        // ‚îÄ‚îÄ 4. DrawingView Ïóê Ï¶âÏãú Î∞òÏòÅ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        drawingView.setTextAnnotations(textAnnos)

        return true
    }

    /* =============================================================== */
    /*  ÌÑ∞Ïπò Î™®Îìú                                                       */
    /* =============================================================== */
    private fun exitTouchMode(){
        if(!isTouchMode) return
        isTouchMode = false
        updateButtonAlpha(null)
    }

    /* =============================================================== */
    /*  Ïï†ÎãàÎ©îÏù¥ÏÖò                                                      */
    /* =============================================================== */
    private fun toggleSideMenu(){
        if(!isMenuOpen){
            sideMenu.startAnimation(slideDown)
        }else{
            slideUp.setAnimationListener(object : Animation.AnimationListener{
                override fun onAnimationStart(a: Animation) {}
                override fun onAnimationRepeat(a: Animation) {}
                override fun onAnimationEnd(a: Animation){
                    sideMenu.visibility = View.VISIBLE
                }
            })
            sideMenu.startAnimation(slideUp)
        }
        isMenuOpen = !isMenuOpen

        // Î≤ÑÌäºÎì§ visibility ÌÜ†Í∏Ä
        val v = if(isMenuOpen) View.VISIBLE else View.GONE
        btnRecord.visibility = v
        btnOcr.visibility = v
        exportButton.visibility = v

        sideMenu.bringToFront()
    }
    /* =============================================================== */
    /*  ÎÖπÏùå                                                           */
    /* =============================================================== */
    // WAV ÎÖπÏùå ÏãúÏûë Ìï®Ïàò
    @SuppressLint("MissingPermission")
    private fun startRecording(btnRecord: ImageButton) {
        if (!checkPermissions()) {
            println("Í∂åÌïúÏù¥ ÏóÜÏñ¥ÏÑú ÎÖπÏùåÏùÑ ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§!")
            requestPermissions()
            return
        }

        isRecording = true
        btnRecord.setImageResource(R.drawable.ic_recording) // ÏïÑÏù¥ÏΩò Î≥ÄÍ≤Ω

        val fileName = generateFileName().replace(".mp3", ".wav") // ÌååÏùº Ïù¥Î¶Ñ ÌôïÏû•Ïûê Î≥ÄÍ≤Ω
        //val storageDir = getExternalFilesDir(Environment.DIRECTORY_MUSIC) // Ïï± ÎÇ¥Î∂Ä Ï†ÄÏû•ÏÜå ÏÇ¨Ïö©
        val storageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) //Îã§Ïö¥Î°úÎìú ÌååÏùº
        val audioFile = File(storageDir, fileName) // ÌååÏùº ÏÉùÏÑ±
        audioFilePath = audioFile.absolutePath

        println("ÌååÏùº Ï†ÄÏû• Í≤ΩÎ°ú: $audioFilePath") // ÌååÏùº Í≤ΩÎ°ú Ï∂úÎ†•

        try {
            val sampleRate = 16000
            val channelConfig = AudioFormat.CHANNEL_IN_MONO
            val audioFormat = AudioFormat.ENCODING_PCM_16BIT
            val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.MIC,
                sampleRate,
                channelConfig,
                audioFormat,
                bufferSize
            )

            val outputStream = FileOutputStream(audioFile)
            writeWavHeader(outputStream, sampleRate, 1, audioFormat)

            audioRecord?.startRecording()

            recordingThread = Thread {
                val buffer = ByteArray(bufferSize)
                while (isRecording) {
                    val read = audioRecord?.read(buffer, 0, buffer.size) ?: 0
                    if (read > 0) {
                        outputStream.write(buffer, 0, read)
                    }
                }
                audioRecord?.stop()
                audioRecord?.release()
                audioRecord = null
                updateWavHeader(audioFile)
                outputStream.close()
                println("WAV ÌååÏùº Ï†ÄÏû• ÏôÑÎ£å: $audioFilePath")
            }

            recordingThread?.start()
            println("WAV ÎÖπÏùå ÏãúÏûëÎê®!")

        } catch (e: Exception) {
            e.printStackTrace()
            println("ÎÖπÏùå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}")
        }
    }


    // ÎÖπÏùå Ï§ëÏßÄ Ìï®Ïàò
    private fun stopRecording(btnRecord: ImageButton) {
        println("ÎÖπÏùå Ï§ëÏßÄ ÏöîÏ≤≠Îê®")

        try {
            isRecording = false
            recordingThread?.join()
            btnRecord.setImageResource(R.drawable.ic_record) // üé§ ÏïÑÏù¥ÏΩò Î≥ÄÍ≤Ω
            println("ÎÖπÏùå ÏôÑÎ£å! ÌååÏùº Ï†ÄÏû• ÏúÑÏπò: $audioFilePath")
        } catch (e: Exception) {
            e.printStackTrace()
            println("ÎÖπÏùå Ï§ëÏßÄ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}")
        }
    }

    private fun writeWavHeader(out: OutputStream, sampleRate: Int, channels: Int, encoding: Int) {
        val bitsPerSample = if (encoding == AudioFormat.ENCODING_PCM_16BIT) 16 else 8
        val byteRate = sampleRate * channels * bitsPerSample / 8

        val header = ByteArray(44)

        // ChunkID "RIFF"
        header[0] = 'R'.code.toByte()
        header[1] = 'I'.code.toByte()
        header[2] = 'F'.code.toByte()
        header[3] = 'F'.code.toByte()

        // ChunkSize (ÏûÑÏãú 0)
        // Format "WAVE"
        header[8] = 'W'.code.toByte()
        header[9] = 'A'.code.toByte()
        header[10] = 'V'.code.toByte()
        header[11] = 'E'.code.toByte()

        // Subchunk1ID "fmt "
        header[12] = 'f'.code.toByte()
        header[13] = 'm'.code.toByte()
        header[14] = 't'.code.toByte()
        header[15] = ' '.code.toByte()

        // Subchunk1Size = 16 for PCM
        header[16] = 16
        header[20] = 1 // PCM
        header[22] = channels.toByte()
        header[24] = (sampleRate and 0xff).toByte()
        header[25] = ((sampleRate shr 8) and 0xff).toByte()
        header[26] = ((sampleRate shr 16) and 0xff).toByte()
        header[27] = ((sampleRate shr 24) and 0xff).toByte()
        header[28] = (byteRate and 0xff).toByte()
        header[29] = ((byteRate shr 8) and 0xff).toByte()
        header[30] = ((byteRate shr 16) and 0xff).toByte()
        header[31] = ((byteRate shr 24) and 0xff).toByte()
        header[32] = (channels * bitsPerSample / 8).toByte()
        header[34] = bitsPerSample.toByte()

        // Subchunk2ID "data" + Subchunk2Size (ÏûÑÏãú 0)
        header[36] = 'd'.code.toByte()
        header[37] = 'a'.code.toByte()
        header[38] = 't'.code.toByte()
        header[39] = 'a'.code.toByte()

        out.write(header, 0, 44)
    }

    private fun updateWavHeader(wavFile: File) {
        val sizes = wavFile.length() - 44
        val header = RandomAccessFile(wavFile, "rw")

        header.seek(4)
        header.write(intToByteArray((sizes + 36).toInt()))
        header.seek(40)
        header.write(intToByteArray(sizes.toInt()))
        header.close()
    }

    private fun intToByteArray(value: Int): ByteArray {
        return byteArrayOf(
            (value and 0xff).toByte(),
            ((value shr 8) and 0xff).toByte(),
            ((value shr 16) and 0xff).toByte(),
            ((value shr 24) and 0xff).toByte()
        )
    }




    // ÌååÏùº Ïù¥Î¶Ñ ÏÉùÏÑ± Ìï®Ïàò (yyyyMMdd_HHmm.mp3 ÌòïÏãù)
    private fun generateFileName(): String {
        val timeStamp = SimpleDateFormat("yyyyMMdd_HHmm", Locale.getDefault()).format(Date())
        return "record_$timeStamp.wav"
    }

    // ÎÖπÏùå Í∂åÌïú ÌôïÏù∏ Ìï®Ïàò
    private fun checkPermissions(): Boolean {
        return try {
            val recordPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)

            println("üîç Í∂åÌïú ÌôïÏù∏ - RECORD_AUDIO: $recordPermission")

            recordPermission == PackageManager.PERMISSION_GRANTED
        } catch (e: Exception) {
            e.printStackTrace()
            println("Í∂åÌïú ÌôïÏù∏ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}")
            false // ÏòàÏô∏ Î∞úÏÉù Ïãú false Î∞òÌôò (Ïï± ÌÅ¨ÎûòÏãú Î∞©ÏßÄ)
        }
    }



    // ÎÖπÏùå Í∂åÌïú ÏöîÏ≤≠ Ìï®Ïàò
    private fun requestPermissions() {
        try {
            println("Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìñâ")
            ActivityCompat.requestPermissions(
                this,
                arrayOf(Manifest.permission.RECORD_AUDIO), //ÌååÏùº Ï†ÄÏû• Í∂åÌïú Ï†úÍ±∞
                200
            )
        } catch (e: Exception) {
            e.printStackTrace()
            println("Í∂åÌïú ÏöîÏ≤≠ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}")
        }
    }


    //Í∂åÌïú ÏäπÏù∏ Ïó¨Î∂Ä ÌôïÏù∏
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        if (requestCode == 200) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                println("Ïò§ÎîîÏò§ ÎÖπÏùå Í∂åÌïúÏù¥ ÏäπÏù∏ÎêòÏóàÏäµÎãàÎã§!")
            } else {
                println("Ïò§ÎîîÏò§ ÎÖπÏùå Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§.")
            }
        }
    }
}